/**
 * This ruleset enforces a secure, client-side read-only model for an IoT application.
 *
 * Core Philosophy:
 * The security model is designed to support a dashboard application where end-users
 * can view data but cannot modify it. All data creation and modification are
 * expected to be performed by trusted backend processes (e.g., a Raspberry Pi using
 * the Firebase Admin SDK), which bypass these client-facing rules. This provides a
 * high level of security by default, preventing any unauthorized data tampering
 * from the client application.
 *
 * Data Structure:
 * The data is organized into four top-level collections:
 * - /iot_devices: Metadata for each physical device.
 * - /leaf_health_data: Time-series sensor readings from devices.
 * - /disease_alerts: Alerts generated based on sensor data.
 * - /device_logs: Operational logs from devices.
 *
 * Key Security Decisions:
 * - Write Access Denied: All client-side write operations (create, update, delete)
 *   are explicitly denied across all collections. This is a critical security measure
 *   because the provided data model does not include a user-to-device ownership
 *   link, making it impossible to authorize user-initiated writes securely.
 * - Authenticated Reads: To support the dashboard functionality, any authenticated
 *   user is permitted to read data from any collection. Anonymous access is denied.
 * - No Data Validation: In line with the prototyping philosophy, these rules do not
 *   validate the shape or type of incoming data, as all write access is blocked
 *   from the client side anyway.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to IoT device metadata.
     * @path /iot_devices/{deviceId}
     * @allow A signed-in user (get): `db.collection('iot_devices').doc('device_123').get()`
     * @deny An anonymous user (get): `db.collection('iot_devices').doc('device_123').get()`
     * @deny Any user (create): `db.collection('iot_devices').doc('device_123').set({ ... })`
     * @principle Allows authenticated clients to read data for display, but prevents any client from creating, modifying, or deleting device records. This assumes a trusted backend manages the device registry.
     */
    match /iot_devices/{deviceId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to leaf health sensor data.
     * @path /leaf_health_data/{leafHealthDataId}
     * @allow A signed-in user (list): `db.collection('leaf_health_data').where('deviceId', '==', 'device_123').get()`
     * @deny An anonymous user (list): `db.collection('leaf_health_data').get()`
     * @deny Any user (update): `db.collection('leaf_health_data').doc('data_abc').update({ temperature: 30 })`
     * @principle Allows authenticated clients to read sensor data for dashboards and charts, but prevents any client from tampering with historical data. Data integrity is maintained by allowing writes only from trusted backend sources.
     */
    match /leaf_health_data/{leafHealthDataId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to disease alerts generated by the system.
     * @path /disease_alerts/{diseaseAlertId}
     * @allow A signed-in user (get): `db.collection('disease_alerts').doc('alert_xyz').get()`
     * @deny An anonymous user (get): `db.collection('disease_alerts').doc('alert_xyz').get()`
     * @deny Any user (delete): `db.collection('disease_alerts').doc('alert_xyz').delete()`
     * @principle Allows authenticated clients to read alerts, but ensures that only a trusted backend can generate or clear these critical notifications.
     */
    match /disease_alerts/{diseaseAlertId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to operational logs from IoT devices.
     * @path /device_logs/{deviceLogId}
     * @allow A signed-in user (list): `db.collection('device_logs').where('logLevel', '==', 'ERROR').get()`
     * @deny An anonymous user (list): `db.collection('device_logs').get()`
     * @deny Any user (create): `db.collection('device_logs').add({ message: 'Fake log entry' })`
     * @principle Allows authenticated clients to read device logs for debugging and monitoring, while preventing clients from injecting false log entries or deleting existing ones.
     */
    match /device_logs/{deviceLogId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}